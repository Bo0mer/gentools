package main

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"io"

	"github.com/Bo0mer/gentools/pkg/astgen"
)

type ocModel struct {
	fileBuilder *astgen.File
	structName  string

	timePackageAlias string
}

func newOcModel(interfacePath, interfaceName, structName, targetPkg string) *ocModel {
	file := astgen.NewFile(targetPkg)
	strct := astgen.NewStruct(structName)
	file.AppendDeclaration(strct)

	m := &ocModel{
		fileBuilder: file,
		structName:  structName,
	}
	m.timePackageAlias = m.AddImport("", "time")
	sourcePackageAlias := m.AddImport("", interfacePath)
	statsAlias := m.AddImport("", "go.opencensus.io/stats")

	constructorBuilder := newConstructorBuilder(statsAlias, sourcePackageAlias, interfaceName)
	file.AppendDeclaration(constructorBuilder)

	strct.AddField("next", sourcePackageAlias, interfaceName)
	strct.AddField("totalOps", statsAlias, "Int64Measure")
	strct.AddField("failedOps", statsAlias, "Int64Measure")
	strct.AddField("opsDuration", statsAlias, "Float64Measure")

	return m
}

func (m *ocModel) WriteSource(w io.Writer) error {
	fmt.Fprintf(w, "// Code generated by mongen. DO NOT EDIT.\n")
	astFile := m.fileBuilder.Build()

	if err := format.Node(w, token.NewFileSet(), astFile); err != nil {
		return err
	}
	return nil
}

func (m *ocModel) AddImport(pkgName, location string) string {
	return m.fileBuilder.AddImport(pkgName, location)
}

func (m *ocModel) AddMethod(method *astgen.MethodConfig) error {
	mmb := NewOCMonitoringMethodBuilder(m.structName, method)

	mmb.SetTimePackageAlias(m.timePackageAlias)

	m.fileBuilder.AppendDeclaration(mmb)
	return nil
}

func (m *ocModel) resolveInterfaceType(location, name string) *ast.SelectorExpr {
	alias := m.AddImport("", location)
	return &ast.SelectorExpr{
		X:   ast.NewIdent(alias),
		Sel: ast.NewIdent(name),
	}
}

// OCMonitoringMethodBuilder is responsible for creating a method that implements
// the original method from the interface and does all the measurement and
// recording logic using opensensus.
type OCMonitoringMethodBuilder struct {
	methodConfig *astgen.MethodConfig
	method       *astgen.Method
	receiverName string

	totalOps    *ast.SelectorExpr // selector for the struct member
	failedOps   *ast.SelectorExpr // selector for the struct member
	opsDuration *ast.SelectorExpr // selector for the struct member

	timePackageAlias string
}

func NewOCMonitoringMethodBuilder(structName string, methodConfig *astgen.MethodConfig) *OCMonitoringMethodBuilder {
	receiverName := "m"
	method := astgen.NewMethod(methodConfig.MethodName, receiverName, structName)

	selexpr := func(fieldName string) *ast.SelectorExpr {
		return &ast.SelectorExpr{
			X:   ast.NewIdent(receiverName),
			Sel: ast.NewIdent(fieldName),
		}
	}

	return &OCMonitoringMethodBuilder{
		methodConfig: methodConfig,
		method:       method,
		receiverName: receiverName,
		totalOps:     selexpr("totalOps"),
		failedOps:    selexpr("failedOps"),
		opsDuration:  selexpr("opsDuration"),
	}
}

func (b *OCMonitoringMethodBuilder) SetTimePackageAlias(alias string) {
	b.timePackageAlias = alias
}

func (b *OCMonitoringMethodBuilder) Build() ast.Decl {
	b.method.SetType(&ast.FuncType{
		Params: &ast.FieldList{
			List: b.methodConfig.MethodParams,
		},
		Results: &ast.FieldList{
			List: fieldsAsAnonymous(b.methodConfig.MethodResults),
		},
	})

	const (
		startFieldName = "start"
	)

	// Add increase total operations statement
	// 	 stats.Record(ctx, m.totalOps.M(1))
	increaseTotalOps := &RecordStat{
		statField: b.totalOps,
	}
	b.method.AddStatement(increaseTotalOps.Build())

	// Add statement to capture current time
	//   start := time.Now()
	b.method.AddStatement(startTimeRecorder{
		timePackageAlias: b.timePackageAlias,
		startFieldName:   startFieldName,
	}.Build())

	// Add method invocation:
	//   result1, result2 := m.next.Method(arg1, arg2)
	methodInvocation := NewMethodInvocation(b.methodConfig)
	methodInvocation.SetReceiver(&ast.SelectorExpr{
		X:   ast.NewIdent(b.receiverName),
		Sel: ast.NewIdent("next"),
	})
	b.method.AddStatement(methodInvocation.Build())

	// Record operation duration
	//   m.opsDuration.Observe(time.Since(start))
	//b.method.AddStatement(NewRecordOpDuraton(b.timePackageAlias, b.opsDuration, b.methodConfig.MethodName).Build())

	// Record operation duration
	//   stats.Record(ctx, m.opsDuration.M(time.Since(start).Seconds()))
	b.method.AddStatement(RecordOpsDurationStats{
		opsDurationField: b.opsDuration,
		startFieldName:   startFieldName,
		timePackageAlias: b.timePackageAlias,
	}.Build())

	// Add increase failed operations statement
	//   if err != nil { m.failedOps.Add(1) }
	b.method.AddStatement(IncrementFailedOps{
		failedOpsField: b.failedOps,
		method:         b.methodConfig,
		counterField:   "failedOps",
	}.Build())

	// Add return statement
	//   return result1, result2
	returnResults := NewReturnResults(b.methodConfig)
	b.method.AddStatement(returnResults.Build())

	return b.method.Build()
}

type RecordStat struct {
	statField *ast.SelectorExpr
}

// Build builds a statement in the form:
// stats.Record(ctx, [statField].M(1))
func (r RecordStat) Build() ast.Stmt {
	return &ast.ExprStmt{
		X: statsRecordCallExpr(&ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   r.statField,
				Sel: ast.NewIdent("M"),
			},
			Args: []ast.Expr{
				&ast.BasicLit{Kind: token.INT, Value: "1"},
			},
		}),
	}
}

type RecordOpsDurationStats struct {
	opsDurationField *ast.SelectorExpr
	startFieldName   string
	timePackageAlias string
}

// Build builds a statement in the form:
// stats.Record(ctx, [opsDurationField].M([timePackageAlias].Since([startFieldName]).Seconds()))
func (r RecordOpsDurationStats) Build() ast.Stmt {
	return &ast.ExprStmt{
		X: statsRecordCallExpr(&ast.CallExpr{
			// stats.Record(ctx, [opsDurationField].M(...)
			Fun: &ast.SelectorExpr{
				X:   r.opsDurationField,
				Sel: ast.NewIdent("M"),
			},
			Args: []ast.Expr{
				// [timePackageAlias].Since([startFieldName]).Seconds()
				&ast.CallExpr{
					Fun: &ast.SelectorExpr{
						X: &ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent(r.timePackageAlias),
								Sel: ast.NewIdent("Since"),
							},
							Args: []ast.Expr{ast.NewIdent(r.startFieldName)},
						},
						Sel: ast.NewIdent("Seconds"),
					},
				},
			},
		}),
	}
}

type IncrementFailedOps struct {
	failedOpsField *ast.SelectorExpr
	method         *astgen.MethodConfig
	counterField   string
}

func (i IncrementFailedOps) Build() ast.Stmt {
	var errorResult ast.Expr
	for _, result := range i.method.MethodResults {
		if id, ok := result.Type.(*ast.Ident); ok {
			if id.Name == "error" {
				errorResult = ast.NewIdent(result.Names[0].String())
				break
			}
		}
	}

	// none of the returns is an error type
	if errorResult == nil {
		return &ast.EmptyStmt{}
	}

	return &ast.IfStmt{
		Cond: &ast.BinaryExpr{
			X:  errorResult,
			Op: token.NEQ,
			Y:  ast.NewIdent("nil"),
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{RecordStat{
				statField: i.failedOpsField,
			}.Build()},
		},
	}
}

// statsRecordCallExpr prepares the opensensus -> stats.Record(ctx, ... statement, sets the
// provided parameter as second argument and returns the built expression.
func statsRecordCallExpr(statToRecord ast.Expr) *ast.CallExpr {
	return &ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   ast.NewIdent("stats"),
			Sel: ast.NewIdent("Record"),
		},
		Args: []ast.Expr{
			ast.NewIdent("ctx"), // fixme - see tracegen/model:169
			statToRecord,
		},
	}
}
