package main

import (
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/format"
	"go/token"
	"io"
	"log"
	"os"
	"path"
	"path/filepath"

	"github.com/Bo0mer/gentools/cmd/mongen/internal/gokit"
	"github.com/Bo0mer/gentools/cmd/mongen/internal/opencensus"

	"github.com/Bo0mer/gentools/pkg/astgen"
	"github.com/Bo0mer/gentools/pkg/resolution"
	"github.com/Bo0mer/gentools/pkg/transformation"
)

const (
	goKitProvider      = "go-kit"
	opencensusProvider = "opencensus"
)

type args struct {
	sourceDir          string
	interfaceName      string
	monitoringProvider string
}

func init() {
	flag.Usage = func() {
		var out io.Writer = os.Stdout

		fmt.Fprintln(out, "A tool that generates monitoring wrappers for interfaces.")
		fmt.Fprintf(out, "Usage: %s [-h] SOURCE_DIR INTERFACE_NAME [PROVIDER]\n", path.Base(os.Args[0]))
		fmt.Fprintln(out, "")
		fmt.Fprintln(out, "  Arguments:")
		fmt.Fprintln(out, "    SOURCE_DIR       Path to the file containing the interface")
		fmt.Fprintln(out, "    INTERFACE_NAME   Name of the interface which will be wrapped")
		fmt.Fprintln(out, "    PROVIDER         Monitoring provider to be used for the generated code")
		fmt.Fprintf(out, "                     Can be one of:  %s  %s\n", goKitProvider, opencensusProvider)
		fmt.Fprintln(out, "")
		fmt.Fprintln(out, "  Options:")
		fmt.Fprintln(out, "    -h               Print this text and exit")
		fmt.Fprintln(out, "")
	}
}

func isValidProvider(provider string) bool {
	return provider == goKitProvider || provider == opencensusProvider
}

func parseArgs() (args, error) {
	flag.Parse()
	if flag.NArg() < 2 {
		return args{}, errors.New("too few arguments provided")
	}

	sourceDir := flag.Arg(0)
	sourceDir, err := filepath.Abs(sourceDir)
	if err != nil {
		return args{}, fmt.Errorf("error determining absolute path to source directory: %v", err)
	}
	interfaceName := flag.Arg(1)

	monitoringProvider := goKitProvider
	if flag.NArg() == 3 {
		monitoringProvider = flag.Arg(2)
		if !isValidProvider(monitoringProvider) {
			return args{}, fmt.Errorf("unknown monitoring provider: %s", monitoringProvider)
		}
	}

	return args{
		sourceDir:          sourceDir,
		interfaceName:      interfaceName,
		monitoringProvider: monitoringProvider,
	}, nil
}

func main() {
	args, err := parseArgs()
	if err != nil {
		log.Fatal(err)
	}

	sourcePkgPath, err := dirToImport(args.sourceDir)
	if err != nil {
		log.Fatalf("error resolving import path of source directory: %v", err)
	}
	targetPkg := path.Base(sourcePkgPath) + "mws"

	locator := resolution.NewLocator()

	context := resolution.NewSingleLocationContext(sourcePkgPath)
	d, err := locator.FindIdentType(context, ast.NewIdent(args.interfaceName))
	if err != nil {
		log.Fatal(err)
	}

	typeName := fmt.Sprintf("monitoring%s", args.interfaceName)

	model, err := newModel(args.monitoringProvider, sourcePkgPath, args.interfaceName, typeName, targetPkg)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	generator := astgen.Generator{
		Model:    model,
		Locator:  locator,
		Resolver: resolution.NewResolver(model, locator),
	}

	err = generator.ProcessInterface(d)
	if err != nil {
		log.Fatal(err)
	}

	targetPkgPath := filepath.Join(args.sourceDir, targetPkg)
	if err := os.MkdirAll(targetPkgPath, 0777); err != nil {
		log.Fatalf("error creating target package directory: %v", err)
	}

	fd, err := os.Create(filepath.Join(targetPkgPath, filename(args.interfaceName)))
	if err != nil {
		log.Fatalf("error creating output source file: %v", err)
	}
	defer fd.Close()

	err = WriteSource(model, fd)
	if err != nil {
		log.Fatal(err)
	}

	wd, _ := os.Getwd()
	outPath, err := filepath.Rel(wd, fd.Name())
	if err != nil {
		outPath = fd.Name()
	}
	fmt.Printf("Wrote monitoring implementation of %q to %q\n", sourcePkgPath+"."+args.interfaceName, outPath)

}

func filename(interfaceName string) string {
	return fmt.Sprintf("monitoring_%s.go", transformation.ToSnakeCase(interfaceName))
}

func dirToImport(p string) (string, error) {
	pkg, err := build.ImportDir(p, build.FindOnly)
	if err != nil {
		return "", err
	}
	return pkg.ImportPath, nil
}

type astFileBuilder interface {
	Build() *ast.File
}

type model interface {
	resolution.Importer
	astgen.ModelBuilder
	astFileBuilder
}

func newModel(provider string, interfacePath, interfaceName, structName, targetPkg string) (model, error) {
	switch provider {
	case goKitProvider:
		return gokit.NewGoKitModel(interfacePath, interfaceName, structName, targetPkg), nil
	case opencensusProvider:
		return opencensus.NewOpencensusModel(interfacePath, interfaceName, structName, targetPkg), nil
	}
	return nil, fmt.Errorf("unknown provider: %s", provider)
}

func WriteSource(generatedFile astFileBuilder, w io.Writer) error {
	fmt.Fprintf(w, "// Code generated by mongen. DO NOT EDIT.\n")
	astFile := generatedFile.Build()

	if err := format.Node(w, token.NewFileSet(), astFile); err != nil {
		return err
	}
	return nil
}
